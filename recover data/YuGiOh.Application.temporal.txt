===== Behaviors/ValidationBehavior.cs =====
using FluentValidation;
using MediatR;

namespace YuGiOh.Application.Behaviors
{
    public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
        where TRequest : IRequest<TResponse>
    {
        private readonly IEnumerable<IValidator<TRequest>> _validators;
        public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
        {
            _validators = validators;
        }
        public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
        {
            if (_validators.Any())
            {
                // Validate using all validators asynchronously
                var validationTasks = _validators
                    .Select(v => v.ValidateAsync(request, cancellationToken));

                var validationResults = await Task.WhenAll(validationTasks);

                var failures = validationResults
                    .SelectMany(r => r.Errors)
                    .Where(f => f != null)
                    .ToList();

                if (failures.Count != 0)
                {
                    // Aggregate and throw all validation errors
                    throw new ValidationException(failures);
                }
            }

            // Continue to the next behavior or handler
            return await next();
        }
    }
}

===== Features/Auth/Commands/AuthenticateCommand.cs =====
using MediatR;
using YuGiOh.Domain.Services;

namespace YuGiOh.Application.Features.Auth.Commands
{
    /// <summary>
    /// Represents a command request for authenticating a user by their credentials.
    /// </summary>
    /// <remarks>
    /// This command is responsible for user login operations.  
    /// It accepts either an email or username as the handler and a password, 
    /// optionally including the IP address of the requester.
    /// </remarks>
    public class AuthenticateCommand : IRequest<(string AccessToken, string RefreshToken)>
    {
        /// <summary>
        /// Gets or sets the user’s identifying handler, which can be an email or username.
        /// </summary>
        /// <remarks>
        /// The authentication process will attempt to resolve the account based on this value.
        /// </remarks>
        public required string Handler { get; set; }

        /// <summary>
        /// Gets or sets the user's password for authentication.
        /// </summary>
        public required string Password { get; set; }

        /// <summary>
        /// Gets or sets the optional IP address from which the login request originated.
        /// </summary>
        /// <remarks>
        /// This value can be used for security auditing or login location validation.
        /// </remarks>
        public string? IpAddress { get; set; }
    }

    /// <summary>
    /// Handles the execution of an <see cref="AuthenticateCommand"/> by invoking
    /// the domain-level authentication logic through <see cref="IAuthenticationHandler"/>.
    /// </summary>
    /// <remarks>
    /// This class acts as the mediator layer between the application command pipeline
    /// and the underlying domain authentication service.
    /// </remarks>
    public class AuthenticateCommandHandler
        : IRequestHandler<AuthenticateCommand, (string AccessToken, string RefreshToken)>
    {
        private readonly IAuthenticationHandler _authenticationHandler;

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticateCommandHandler"/> class.
        /// </summary>
        /// <param name="authenticationHandler">The authentication service responsible for verifying credentials and issuing tokens.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="authenticationHandler"/> is null.</exception>
        public AuthenticateCommandHandler(IAuthenticationHandler authenticationHandler)
        {
            _authenticationHandler = authenticationHandler
                ?? throw new ArgumentNullException(nameof(authenticationHandler));
        }

        /// <summary>
        /// Handles the authentication process using the provided command data.
        /// </summary>
        /// <param name="request">The authentication command containing credentials and optional IP address.</param>
        /// <param name="cancellationToken">A token to cancel the operation if needed.</param>
        /// <returns>
        /// A tuple containing the generated <c>AccessToken</c> and <c>RefreshToken</c> for the authenticated user.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown when the <paramref name="request"/> is null.</exception>
        public async Task<(string AccessToken, string RefreshToken)> Handle(
            AuthenticateCommand request,
            CancellationToken cancellationToken)
        {
            // Ensure the command is valid
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            // Delegate to the domain authentication handler
            return await _authenticationHandler.AuthenticateAsync(
                request.Handler,
                request.Password,
                request.IpAddress
            );
        }
    }
}


===== Features/Auth/Commands/RefreshTokenCommand.cs =====
using MediatR;
using YuGiOh.Domain.Services;

namespace YuGiOh.Application.Features.Auth.Commands
{
    /// <summary>
    /// Represents a command request to refresh a user's authentication tokens.
    /// </summary>
    /// <remarks>
    /// This command is used when a user provides a valid refresh token
    /// to obtain a new access token and refresh token pair.
    /// It follows the CQRS pattern through the MediatR library.
    /// </remarks>
    public class RefreshTokenCommand : IRequest<(string AccessToken, string RefreshToken)>
    {
        /// <summary>
        /// Gets or sets the refresh token used to validate the request
        /// and issue a new pair of authentication tokens.
        /// </summary>
        public required string RefreshToken { get; set; }

        /// <summary>
        /// Gets or sets the IP address from which the token refresh request originated.
        /// </summary>
        /// <remarks>
        /// This value may be used for security logging or to verify token validity
        /// against the issuing device or session.
        /// </remarks>
        public required string IpAddress { get; set; }
    }

    /// <summary>
    /// Handles the execution of a <see cref="RefreshTokenCommand"/> by delegating the
    /// token refresh process to an <see cref="IAuthenticationHandler"/> implementation.
    /// </summary>
    /// <remarks>
    /// This handler forms part of the Application layer and mediates between the
    /// presentation tier (API/controllers) and the domain authentication logic.
    /// </remarks>
    public class RefreshTokenCommandHandler : IRequestHandler<RefreshTokenCommand, (string AccessToken, string RefreshToken)>
    {
        private readonly IAuthenticationHandler _authenticationHandler;

        /// <summary>
        /// Initializes a new instance of the <see cref="RefreshTokenCommandHandler"/> class.
        /// </summary>
        /// <param name="authenticationHandler">The authentication service responsible for refreshing tokens.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="authenticationHandler"/> is null.</exception>
        public RefreshTokenCommandHandler(IAuthenticationHandler authenticationHandler)
        {
            _authenticationHandler = authenticationHandler
                ?? throw new ArgumentNullException(nameof(authenticationHandler));
        }

        /// <summary>
        /// Handles the refresh token request by invoking domain logic to generate new tokens.
        /// </summary>
        /// <param name="request">The refresh token command containing the current token and client IP.</param>
        /// <param name="cancellationToken">A token that can be used to cancel the operation.</param>
        /// <returns>
        /// A tuple containing the new <c>AccessToken</c> and <c>RefreshToken</c> strings.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown when the <paramref name="request"/> is null.</exception>
        public async Task<(string AccessToken, string RefreshToken)> Handle(
            RefreshTokenCommand request,
            CancellationToken cancellationToken)
        {
            // Validate request
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            // Delegate to the domain authentication service to handle refresh logic
            return await _authenticationHandler.RefreshAsync(request.RefreshToken, request.IpAddress);
        }
    }
}


===== Features/Auth/Commands/RegisterCommand.cs =====
using MediatR;
using YuGiOh.Domain.DTOs;
using YuGiOh.Domain.Services;

namespace YuGiOh.Application.Features.Auth.Commands
{
    /// <summary>
    /// Represents a command request to register a new user.
    /// </summary>
    /// <remarks>
    /// This class follows the CQRS pattern using MediatR.
    /// It encapsulates the data required to register a new account and returns a confirmation token string.
    /// </remarks>
    public class RegisterCommand : IRequest<string>
    {
        /// <summary>
        /// Gets or sets the registration data that contains all user information
        /// (e.g., email, password, address, and roles) required for creating the account.
        /// </summary>
        public required RegisterRequestData Data { get; set; }
    }

    /// <summary>
    /// Handles the <see cref="RegisterCommand"/> execution logic.
    /// </summary>
    /// <remarks>
    /// This handler delegates the actual registration process to an injected <see cref="IRegisterHandler"/> service.
    /// It acts as a mediator entry point from the Application layer to the Domain/Infrastructure layer.
    /// </remarks>
    public class RegisterCommandHandler : IRequestHandler<RegisterCommand, string>
    {
        private readonly IRegisterHandler _registerHandler;

        /// <summary>
        /// Initializes a new instance of the <see cref="RegisterCommandHandler"/> class.
        /// </summary>
        /// <param name="registerHandler">The service responsible for handling user registration logic.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="registerHandler"/> is null.</exception>
        public RegisterCommandHandler(IRegisterHandler registerHandler)
        {
            _registerHandler = registerHandler
                ?? throw new ArgumentNullException(nameof(registerHandler));
        }

        /// <summary>
        /// Handles the registration command by invoking the domain registration logic.
        /// </summary>
        /// <param name="request">The registration command containing the user’s registration data.</param>
        /// <param name="cancellationToken">A token to observe while waiting for the task to complete.</param>
        /// <returns>
        /// A <see cref="string"/> representing the confirmation token sent to the user’s email.
        /// </returns>
        public async Task<string> Handle(RegisterCommand request, CancellationToken cancellationToken)
        {
            // Extract the user registration data from the command
            var registerUser = request.Data;

            // Delegate the registration process to the domain service.
            // The result is typically an email confirmation token.
            return await _registerHandler.RegisterUserAsync(registerUser);
        }
    }
}


===== Features/Auth/Commands/SendConfirmationEmailCommand.cs =====
using MediatR;
using YuGiOh.Domain.DTOs;
using YuGiOh.Domain.Services;

namespace YuGiOh.Application.Features.Auth.Commands
{
    /// <summary>
    /// Represents a command request to send a confirmation email to a newly registered user.
    /// </summary>
    /// <remarks>
    /// This command encapsulates the necessary information to generate and send a 
    /// confirmation email, such as the recipient's email address and the callback URL
    /// used to confirm their registration.
    /// </remarks>
    public class SendConfirmationEmailCommand : IRequest
    {
        /// <summary>
        /// Gets or sets the recipient's email address where the confirmation message will be sent.
        /// </summary>
        public required string Email { get; set; }

        /// <summary>
        /// Gets or sets the callback URL included in the confirmation email, allowing the user 
        /// to complete their registration.
        /// </summary>
        public required string CallbackURL { get; set; }
    }

    /// <summary>
    /// Handles the <see cref="SendConfirmationEmailCommand"/> by generating and sending
    /// a confirmation email using the configured email provider and sender services.
    /// </summary>
    /// <remarks>
    /// This handler delegates the email content generation to an <see cref="IEmailProvider"/>
    /// and the sending process to an <see cref="IEmailSender"/> implementation.
    /// </remarks>
    public class SendConfirmationEmailCommandHandler : IRequestHandler<SendConfirmationEmailCommand>
    {
        private readonly IEmailSender _emailSender;
        private readonly IEmailProvider _emailProvider;

        /// <summary>
        /// Initializes a new instance of the <see cref="SendConfirmationEmailCommandHandler"/> class.
        /// </summary>
        /// <param name="emailSender">Service responsible for sending emails.</param>
        /// <param name="emailProvider">Service responsible for generating email templates and content.</param>
        /// <exception cref="ArgumentNullException">Thrown when any dependency is null.</exception>
        public SendConfirmationEmailCommandHandler(
            IEmailSender emailSender,
            IEmailProvider emailProvider)
        {
            _emailSender = emailSender ?? throw new ArgumentNullException(nameof(emailSender));
            _emailProvider = emailProvider ?? throw new ArgumentNullException(nameof(emailProvider));
        }

        /// <summary>
        /// Handles the process of composing and sending a confirmation email.
        /// </summary>
        /// <param name="request">The command containing the recipient’s email and callback URL.</param>
        /// <param name="cancellationToken">A token to cancel the operation, if needed.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="request"/> is null.</exception>
        public async Task Handle(SendConfirmationEmailCommand request, CancellationToken cancellationToken)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            // Generate the confirmation email using the provider
            EmailMessageDTO emailData = _emailProvider.GenerateConfirmRegistrationEmail(request.Email, request.CallbackURL);

            // Send the composed email using the configured sender
            await _emailSender.SendMailAsync(emailData);
        }
    }
}


===== Features/Auth/Queries/ConfirmEmailQuery.cs =====
using MediatR;
using YuGiOh.Domain.Services;

namespace YuGiOh.Application.Features.Auth.Queries
{
    /// <summary>
    /// Represents a query to confirm a user's email address using a verification token.
    /// </summary>
    /// <remarks>
    /// This query is part of the authentication flow and is typically executed
    /// when a user clicks on a confirmation link sent to their email after registration.
    /// </remarks>
    public class ConfirmEmailQuery : IRequest<bool>
    {
        /// <summary>
        /// Gets or sets the email address of the user whose registration is being confirmed.
        /// </summary>
        public required string Email { get; set; }

        /// <summary>
        /// Gets or sets the confirmation token associated with the user's registration.
        /// </summary>
        public required string Token { get; set; }
    }

    /// <summary>
    /// Handles the execution of the <see cref="ConfirmEmailQuery"/> by invoking
    /// the registration service responsible for validating and confirming the user's email.
    /// </summary>
    /// <remarks>
    /// This handler communicates with the <see cref="IRegisterHandler"/> service in the domain layer
    /// to perform token validation and complete the account activation process.
    /// </remarks>
    public class ConfirmEmailQueryHandler : IRequestHandler<ConfirmEmailQuery, bool>
    {
        private readonly IRegisterHandler _registerHandler;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfirmEmailQueryHandler"/> class.
        /// </summary>
        /// <param name="registerHandler">The service responsible for handling user registration logic.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="registerHandler"/> is null.</exception>
        public ConfirmEmailQueryHandler(IRegisterHandler registerHandler)
        {
            _registerHandler = registerHandler
                ?? throw new ArgumentNullException(nameof(registerHandler));
        }

        /// <summary>
        /// Handles the email confirmation process by validating the provided token for the specified email.
        /// </summary>
        /// <param name="request">The query containing the user's email and confirmation token.</param>
        /// <param name="cancellationToken">A token used to cancel the operation if necessary.</param>
        /// <returns>
        /// <c>true</c> if the confirmation was successful; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown when the <paramref name="request"/> is null.</exception>
        public async Task<bool> Handle(ConfirmEmailQuery request, CancellationToken cancellationToken)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            // Delegate confirmation logic to the domain registration handler
            return await _registerHandler.ConfirmRegistrationAsync(request.Email, request.Token);
        }
    }
}


===== Features/Auth/Validators/AuthetnticateCommandValidator.cs =====
using FluentValidation;
using YuGiOh.Application.Features.Auth.Commands;

namespace YuGiOh.Application.Features.Auth.Validators
{
    public class AuthenticateCommandValidator : AbstractValidator<AuthenticateCommand>
    {
        public AuthenticateCommandValidator()
        {
            RuleFor(x => x.Handler)
                .NotEmpty().WithMessage("Username or email is required.")
                .MaximumLength(255)
                // optional — detect obvious invalid emails if they are provided
                .Matches(@"^[^@\s]+@[^@\s]+\.[^@\s]+$")
                .When(x => x.Handler.Contains('@'))
                .WithMessage("Invalid email format.");

            RuleFor(x => x.Password)
                .NotEmpty().WithMessage("Password is required.")
                .MinimumLength(8).WithMessage("Password must be at least 8 characters long.");

            RuleFor(x => x.IpAddress)
                .NotEmpty().WithMessage("IpAddress is required.")
                .Matches(@"^([0-9]{1,3}\.){3}[0-9]{1,3}$|^([a-fA-F0-9:]+)$")
                .WithMessage("Invalid IP address format.");
        }
    }
}


===== Features/Auth/Validators/RefreshTokenCommandValidator.cs =====
using FluentValidation;
using YuGiOh.Application.Features.Auth.Commands;

namespace YuGiOh.Application.Features.Auth.Validators
{
    public class RefreshTokenCommandValidator : AbstractValidator<RefreshTokenCommand>
    {
        public RefreshTokenCommandValidator()
        {
            RuleFor(x => x.RefreshToken)
                .NotEmpty().WithMessage("Refresh token is required.")
                .MinimumLength(20).WithMessage("Refresh token appears to be invalid (too short).")
                .MaximumLength(500).WithMessage("Refresh token appears to be invalid (too long).")
                // Base64 validation pattern: A-Z, a-z, 0-9, +, /, possibly ending with = padding
                .Matches(@"^[A-Za-z0-9+/]*={0,2}$")
                .WithMessage("Refresh token must be a valid Base64 string.");

            RuleFor(x => x.IpAddress)
                .NotEmpty().WithMessage("IP address is required.")
                // IPv4 or IPv6 format
                .Matches(@"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}$|^([a-fA-F0-9:]+)$")
                .WithMessage("Invalid IP address format.");
        }
    }
}


===== Features/Auth/Validators/RegisterCommandValidator.cs =====
using FluentValidation;
using YuGiOh.Application.Features.Auth.Commands;

namespace YuGiOh.Application.Features.Auth.Validators
{
    public class RegisterCommandValidator : AbstractValidator<RegisterCommand>
    {
        public RegisterCommandValidator()
        {
            RuleFor(x => x.Data)
                .NotNull().WithMessage("Registration data is required.")
                .SetValidator(new RegisterRequestDataValidator());
        }
    }
}


===== Features/Auth/Validators/RegisterRequestDataValidator.cs =====
using FluentValidation;

using YuGiOh.Domain.DTOs;
using YuGiOh.Application.Features.Common.Validators;

namespace YuGiOh.Application.Features.Auth.Validators
{
    public class RegisterRequestDataValidator : AbstractValidator<RegisterRequestData>
    {
        public RegisterRequestDataValidator()
        {
            RuleFor(x => x.Email)
                .NotEmpty().WithMessage("Email is required.")
                .EmailAddress().WithMessage("Invalid email format.")
                .MaximumLength(255);

            RuleFor(x => x.Password)
                .NotEmpty().WithMessage("Password is required.")
                .MinimumLength(8).WithMessage("Password must be at least 8 characters.")
                .Matches("[A-Z]").WithMessage("Password must contain at least one uppercase letter.")
                .Matches("[a-z]").WithMessage("Password must contain at least one lowercase letter.")
                .Matches("[0-9]").WithMessage("Password must contain at least one number.")
                .Matches("[^a-zA-Z0-9]").WithMessage("Password must contain at least one special character.");

            RuleFor(x => x.FirstName)
                .NotEmpty().WithMessage("First name is required.")
                .MaximumLength(100)
                .Matches("^[A-Za-z]+$").WithMessage("First name must contain only Latin letters (A-Z, a-z).");

            RuleFor(x => x.MiddleName)
                .MaximumLength(100)
                .Matches("^[A-Za-z]+$")
                    .When(x => !string.IsNullOrWhiteSpace(x.MiddleName))
                    .WithMessage("Middle name must contain only Latin letters (A-Z, a-z).");

            RuleFor(x => x.FirstSurname)
                .NotEmpty().WithMessage("First surname is required.")
                .MaximumLength(100)
                .Matches("^[A-Za-z]+$").WithMessage("First surname must contain only Latin letters (A-Z, a-z).");

            RuleFor(x => x.SecondSurname)
                .NotEmpty().WithMessage("Second surname is required.")
                .MaximumLength(100)
                .Matches("^[A-Za-z]+$").WithMessage("Second surname must contain only Latin letters (A-Z, a-z).");


            RuleFor(x => x.Roles)
                .NotNull().WithMessage("At least one role must be provided.")
                .Must(r => r.Any()).WithMessage("At least one role must be provided.")
                .ForEach(r => r.NotEmpty().WithMessage("Role names cannot be empty."));

            // Nested Address validator
            When(x => x.Address != null, () =>
            {
                RuleFor(x => x.Address!)
                    .SetValidator(new AddressValidator());
            });

            // Conditional IBAN rule
            When(x => x.Roles.Contains("Sponsor"), () =>
            {
                RuleFor(x => x.IBAN)
                    .NotEmpty().WithMessage("IBAN is required for sponsors.")
                    .Length(15, 34).WithMessage("IBAN must be between 15 and 34 characters.")
                    .Matches("^[A-Z]{2}[0-9A-Z]{13,32}$").WithMessage("Invalid IBAN format.");
            });
        }
    }
}


===== Features/Auth/Validators/SendConfirmationEmailValidator.cs =====
using FluentValidation;

using YuGiOh.Application.Features.Auth.Commands;

namespace YuGiOh.Application.Features.Auth.Validators
{
    public class SendConfirmationEmailCommandValidator : AbstractValidator<SendConfirmationEmailCommand>
    {
        public SendConfirmationEmailCommandValidator()
        {
            RuleFor(x => x.Email)
                .NotEmpty().WithMessage("Email is required.")
                .EmailAddress().WithMessage("Invalid email format.");

            RuleFor(x => x.CallbackURL)
                .NotEmpty().WithMessage("Callback URL is required.")
                .Must(uri => Uri.TryCreate(uri, UriKind.Absolute, out _))
                .WithMessage("Callback URL must be a valid absolute URL.");
        }
    }
}


===== Features/Common/Validators/AddressValidator.cs =====
using FluentValidation;
using YuGiOh.Domain.Models;

namespace YuGiOh.Application.Features.Common.Validators
{
    public class AddressValidator : AbstractValidator<Address>
    {
        public AddressValidator()
        {
            RuleFor(a => a.CountryIso2)
                .NotEmpty().WithMessage("Country code is required.")
                .Length(2).WithMessage("Country code must be 2 characters.");

            RuleFor(a => a.StateIso2)
                .MaximumLength(10)
                .When(a => !string.IsNullOrEmpty(a.StateIso2));

            RuleFor(a => a.City)
                .MaximumLength(100)
                .When(a => !string.IsNullOrEmpty(a.City));

            RuleFor(a => a.StreetName)
                .MaximumLength(200)
                .When(a => !string.IsNullOrEmpty(a.StreetName));

            RuleFor(a => a.Building)
                .MaximumLength(100)
                .When(a => !string.IsNullOrEmpty(a.Building));

            RuleFor(a => a.Apartment)
                .MaximumLength(50)
                .When(a => !string.IsNullOrEmpty(a.Apartment));
        }
    }
}


===== obj/Debug/net7.0/.NETCoreApp,Version=v7.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v7.0", FrameworkDisplayName = ".NET 7.0")]


===== obj/Debug/net7.0/YuGiOh.Application.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("YuGiOh.Application")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("YuGiOh.Application")]
[assembly: System.Reflection.AssemblyTitleAttribute("YuGiOh.Application")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



===== obj/Debug/net7.0/YuGiOh.Application.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;


===== ServiceExtension.cs =====
﻿using YuGiOh.Application.Behaviors;

using MediatR;
using FluentValidation;
using System.Reflection;
using Microsoft.Extensions.DependencyInjection;

namespace YuGiOh.Application
{
    public static class ServiceExtension
    {
        public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
        {
            // services.AddAutoMapper(Assembly.GetExecutingAssembly());

            services.AddMediatR(cfg =>
                cfg.RegisterServicesFromAssembly(typeof(ServiceExtension).Assembly));

            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
            services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));

            return services;
        }
    }
}



===== YuGiOh.Application.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <ProjectReference Include="..\YuGiOh.Domain\YuGiOh.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Ardalis.Specification" Version="8.0.0" />
    <PackageReference Include="FluentValidation" Version="11.8.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.8.0" />
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="MediatR.Extensions.Microsoft.DependencyInjection" Version="11.1.0" />
  </ItemGroup>

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>


