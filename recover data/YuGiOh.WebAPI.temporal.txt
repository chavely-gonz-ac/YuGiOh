===== Controllers/APIControllerBase.cs =====
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace YuGiOh.WebAPI.Controllers
{
    /// <summary>
    /// Serves as the base class for all API controllers in the application.
    /// </summary>
    /// <remarks>
    /// This abstract base controller provides shared functionality for derived controllers,
    /// including access to the MediatR <see cref="ISender"/> instance used to send commands and queries
    /// through the mediator pipeline.
    /// </remarks>
    [ApiController]
    [Route("api/[controller]/[action]")]
    public abstract class APIControllerBase : ControllerBase
    {
        /// <summary>
        /// The MediatR sender instance used to dispatch requests (commands and queries)
        /// to their respective handlers in the application layer.
        /// </summary>
        private readonly ISender _sender;

        /// <summary>
        /// Provides access to the MediatR <see cref="ISender"/> for use by derived controllers.
        /// </summary>
        protected ISender Sender => _sender;

        /// <summary>
        /// Initializes a new instance of the <see cref="APIControllerBase"/> class.
        /// </summary>
        /// <param name="sender">The MediatR sender instance used for request dispatching.</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the <paramref name="sender"/> dependency is null.
        /// </exception>
        protected APIControllerBase(ISender sender)
        {
            _sender = sender ?? throw new ArgumentNullException(nameof(sender));
        }
    }
}


===== Controllers/AuthenticationController.cs =====
using MediatR;
using Microsoft.AspNetCore.Mvc;
using YuGiOh.Application.Features.Auth.Commands;

namespace YuGiOh.WebAPI.Controllers
{
    /// <summary>
    /// Provides endpoints for user authentication, including login and token refresh operations.
    /// </summary>
    /// <remarks>
    /// This controller handles authentication-related actions such as issuing access and refresh tokens,
    /// as well as renewing tokens securely via HTTP-only cookies.
    /// </remarks>
    [Route("api/[controller]")]
    [ApiController]
    public class AuthenticationController : APIControllerBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationController"/> class.
        /// </summary>
        /// <param name="mediator">The MediatR instance used for dispatching authentication commands.</param>
        public AuthenticationController(IMediator mediator) : base(mediator) { }

        /// <summary>
        /// Authenticates a user and issues a new access token and refresh token.
        /// </summary>
        /// <param name="request">The authentication command containing credentials and optional IP address.</param>
        /// <returns>
        /// A JSON object containing the access token, while storing the refresh token in a secure HttpOnly cookie.
        /// </returns>
        /// <response code="200">Returns the generated access token.</response>
        /// <response code="400">Returned when the request data is invalid or missing credentials.</response>
        /// <response code="401">Returned when authentication fails due to invalid credentials.</response>
        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] AuthenticateCommand request)
        {
            // Basic request validation
            if (request == null)
                return BadRequest("Invalid request data.");

            if (string.IsNullOrWhiteSpace(request.Handler) || string.IsNullOrWhiteSpace(request.Password))
                return BadRequest("Handler and password are required.");

            // Auto-fill the request IP address if not provided by the client
            if (string.IsNullOrWhiteSpace(request.IpAddress))
            {
                request.IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
            }

            try
            {
                // Execute the authentication command through MediatR
                var tokens = await Sender.Send(request);

                // Store refresh token securely in an HTTP-only cookie
                Response.Cookies.Append("refreshToken", tokens.RefreshToken, new CookieOptions
                {
                    HttpOnly = true,           // inaccessible to JavaScript
                    Secure = true,             // requires HTTPS
                    SameSite = SameSiteMode.Strict,
                    Expires = DateTime.UtcNow.AddDays(7) // should match backend refresh token lifetime
                });

                // Return the access token to the client (refresh token remains in the cookie)
                return Ok(new
                {
                    AccessToken = tokens.AccessToken
                });
            }
            catch (Exception ex)
            {
                // Return a sanitized unauthorized response (avoid exposing internal error details)
                return Unauthorized(new { Message = ex.Message });
            }
        }

        /// <summary>
        /// Refreshes the user's access token using the refresh token stored in a secure cookie.
        /// </summary>
        /// <returns>
        /// A JSON object containing a new access token and an updated refresh token (rotated in the cookie).
        /// </returns>
        /// <response code="200">Returns the new access token and rotates the refresh token cookie.</response>
        /// <response code="400">Returned when the refresh token cookie is missing or invalid.</response>
        /// <response code="401">Returned when the refresh token is expired or invalid.</response>
        [HttpPost("refresh")]
        public async Task<IActionResult> Refresh()
        {
            // Retrieve the refresh token from the secure cookie
            var refreshToken = Request.Cookies["refreshToken"];
            var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";

            if (string.IsNullOrWhiteSpace(refreshToken))
                return BadRequest("Refresh token cookie missing.");

            try
            {
                // Execute the refresh command via MediatR
                var tokens = await Sender.Send(new RefreshTokenCommand
                {
                    RefreshToken = refreshToken,
                    IpAddress = ipAddress
                });

                // Rotate the refresh token by setting a new cookie
                Response.Cookies.Append("refreshToken", tokens.RefreshToken, new CookieOptions
                {
                    HttpOnly = true,
                    Secure = true,
                    SameSite = SameSiteMode.Strict,
                    Expires = DateTime.UtcNow.AddDays(7)
                });

                return Ok(new
                {
                    tokens.AccessToken
                });
            }
            catch (Exception ex)
            {
                // Return unauthorized with safe message
                return Unauthorized(new { Message = ex.Message });
            }
        }
    }
}


===== Controllers/CSCController.cs =====
using MediatR;
using Microsoft.AspNetCore.Mvc;
using YuGiOh.Domain.DTOs;
using YuGiOh.Domain.Models;
using YuGiOh.Domain.Services;

namespace YuGiOh.WebAPI.Controllers
{
    /// <summary>
    /// Provides endpoints for retrieving country, state, city, and street type data
    /// from the CSC (Country-State-City) service.
    /// </summary>
    /// <remarks>
    /// This controller acts as a simple façade between the Web API layer and the
    /// <see cref="ICSCProvider"/> service, which handles data retrieval and caching.
    /// </remarks>
    [ApiController]
    [Route("api/[controller]/[action]")]
    public class CSCController : APIControllerBase
    {
        private readonly ICSCProvider _cscProvider;

        /// <summary>
        /// Initializes a new instance of the <see cref="CSCController"/> class.
        /// </summary>
        /// <param name="mediator">The MediatR mediator instance used for command/query dispatching.</param>
        /// <param name="cscProvider">The service provider responsible for country, state, and city data retrieval.</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="mediator"/> or <paramref name="cscProvider"/> is null.
        /// </exception>
        public CSCController(
            IMediator mediator,
            ICSCProvider cscProvider) : base(mediator)
        {
            _cscProvider = cscProvider ?? throw new ArgumentNullException(nameof(cscProvider));
        }

        /// <summary>
        /// Retrieves all countries supported by the CSC service.
        /// </summary>
        /// <returns>A list of <see cref="Country"/> entities.</returns>
        /// <response code="200">Successfully retrieved all countries.</response>
        [HttpGet]
        [ProducesResponseType(typeof(ICollection<Country>), 200)]
        public async Task<IActionResult> GetCountries()
        {
            ICollection<Country> result = await _cscProvider.GetAllCountriesAsync();
            return Ok(result);
        }

        /// <summary>
        /// Retrieves all states belonging to a specific country.
        /// </summary>
        /// <param name="countryIso2">The ISO2 code of the country (e.g., "US", "MX", "JP").</param>
        /// <returns>A list of <see cref="State"/> entities.</returns>
        /// <response code="200">Successfully retrieved all states for the specified country.</response>
        /// <response code="400">Returned when the country code is invalid or missing.</response>
        [HttpGet("{countryIso2}")]
        [ProducesResponseType(typeof(ICollection<State>), 200)]
        [ProducesResponseType(400)]
        public async Task<IActionResult> GetStates(string countryIso2)
        {
            if (string.IsNullOrWhiteSpace(countryIso2))
                return BadRequest("Country ISO2 code is required.");

            var result = await _cscProvider.GetStatesByCountryAsync(countryIso2);
            return Ok(result);
        }

        /// <summary>
        /// Retrieves all cities belonging to a specific state within a given country.
        /// </summary>
        /// <param name="countryIso2">The ISO2 code of the country (e.g., "US").</param>
        /// <param name="stateIso2">The ISO2 code of the state or region (e.g., "CA").</param>
        /// <returns>A list of <see cref="City"/> entities.</returns>
        /// <response code="200">Successfully retrieved all cities for the specified state.</response>
        /// <response code="400">Returned when either ISO2 code is invalid or missing.</response>
        [HttpGet("{countryIso2}/{stateIso2}")]
        [ProducesResponseType(typeof(ICollection<City>), 200)]
        [ProducesResponseType(400)]
        public async Task<IActionResult> GetCities(string countryIso2, string stateIso2)
        {
            if (string.IsNullOrWhiteSpace(countryIso2) || string.IsNullOrWhiteSpace(stateIso2))
                return BadRequest("Both country and state ISO2 codes are required.");

            var result = await _cscProvider.GetCitiesByStateAsync(countryIso2, stateIso2);
            return Ok(result);
        }

        /// <summary>
        /// Retrieves all street types available in the system (e.g., Avenue, Boulevard, Street).
        /// </summary>
        /// <returns>A list of <see cref="StreetType"/> entities.</returns>
        /// <response code="200">Successfully retrieved all street types.</response>
        [HttpGet]
        [ProducesResponseType(typeof(ICollection<StreetType>), 200)]
        public async Task<IActionResult> GetStreetTypes()
        {
            var result = await _cscProvider.GetStreetTypesAsync();
            return Ok(result);
        }
    }
}


===== Controllers/RegisterController.cs =====
using MediatR;
using Microsoft.AspNetCore.Mvc;
using YuGiOh.Application.Features.Auth.Queries;
using YuGiOh.Application.Features.Auth.Commands;
using YuGiOh.Domain.DTOs;

namespace YuGiOh.WebAPI.Controllers
{
    /// <summary>
    /// Provides endpoints for user registration and email confirmation operations.
    /// </summary>
    /// <remarks>
    /// This controller handles the registration workflow, including:
    /// <list type="number">
    /// <item>Receiving registration data and creating a new account.</item>
    /// <item>Sending an email confirmation link to the registered user.</item>
    /// <item>Validating and confirming the user’s email address.</item>
    /// </list>
    /// </remarks>
    [ApiController]
    [Route("api/[controller]/[action]")]
    public class RegisterController : APIControllerBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RegisterController"/> class.
        /// </summary>
        /// <param name="mediator">The MediatR instance used for dispatching registration and email commands.</param>
        public RegisterController(IMediator mediator) : base(mediator) { }

        /// <summary>
        /// Registers a new user and sends them an email confirmation link.
        /// </summary>
        /// <param name="request">The registration data containing user details and credentials.</param>
        /// <returns>
        /// Returns a success message if registration and email sending succeed,
        /// or an appropriate error response if a failure occurs.
        /// </returns>
        /// <response code="200">Registration completed successfully, awaiting email confirmation.</response>
        /// <response code="400">Returned when the registration request is invalid.</response>
        /// <response code="500">Returned when an unexpected server error occurs during registration.</response>
        [HttpPost]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> Register([FromBody] RegisterRequestData request)
        {
            if (request == null)
                return BadRequest("Invalid registration request.");

            try
            {
                // Dispatch the registration command via MediatR
                var token = await Sender.Send(new RegisterCommand { Data = request });

                // Build the callback URL for email confirmation
                var callbackUrl = Url.Action(
                    nameof(ConfirmEmail),
                    "Register",
                    new { email = request.Email, token },
                    Request.Scheme);

                // Dispatch the command to send the confirmation email
                await Sender.Send(new SendConfirmationEmailCommand
                {
                    Email = request.Email,
                    CallbackURL = callbackUrl!
                });

                return Ok(new { Message = "Registration successful. Please check your email to confirm your account." });
            }
            catch (Exception ex)
            {
                // Log for diagnostics (could be integrated with structured logging middleware)
                Console.WriteLine($"[Register Error] {ex.Message}");
                return StatusCode(500, "An error occurred during registration. Please try again later.");
            }
        }

        /// <summary>
        /// Confirms a user's email address using the verification link sent during registration.
        /// </summary>
        /// <param name="email">The user's email address.</param>
        /// <param name="token">The confirmation token sent via email.</param>
        /// <returns>
        /// Returns a simple HTML confirmation page indicating success or failure.
        /// </returns>
        /// <response code="200">Displays a confirmation message.</response>
        [HttpGet]
        public async Task<IActionResult> ConfirmEmail([FromQuery] string email, [FromQuery] string token)
        {
            if (string.IsNullOrWhiteSpace(email) || string.IsNullOrWhiteSpace(token))
            {
                return Content(BuildHtmlPage("Invalid email or token.", "http://localhost:3000/login"), "text/html");
            }

            try
            {
                var command = new ConfirmEmailQuery { Email = email, Token = token };
                var result = await Sender.Send(command);

                if (result)
                    return Content(BuildHtmlPage("Email confirmed successfully!", "http://localhost:3000/login"), "text/html");

                return Content(BuildHtmlPage("Invalid or expired confirmation link.", "http://localhost:3000/login"), "text/html");
            }
            catch (Exception)
            {
                return Content(BuildHtmlPage("An error occurred while confirming your email.", "http://localhost:3000/login"), "text/html");
            }
        }

        /// <summary>
        /// Builds a simple styled HTML page for displaying confirmation results to the user.
        /// </summary>
        /// <param name="message">The message to display to the user.</param>
        /// <param name="loginUrl">The URL to redirect the user to the login page.</param>
        /// <returns>An HTML string representing the page.</returns>
        private string BuildHtmlPage(string message, string loginUrl)
        {
            return $@"
            <!DOCTYPE html>
            <html lang='en'>
            <head>
                <meta charset='UTF-8'>
                <meta name='viewport' content='width=device-width, initial-scale=1.0'>
                <title>Email Confirmation</title>
                <style>
                    body {{
                        font-family: Arial, sans-serif;
                        background: linear-gradient(135deg, #e0bbff, #d1a3ff);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        height: 100vh;
                        margin: 0;
                    }}
                    .card {{
                        background-color: #fff;
                        padding: 2rem 3rem;
                        border-radius: 12px;
                        text-align: center;
                        box-shadow: 0 8px 16px rgba(0,0,0,0.2);
                    }}
                    h1 {{
                        color: #4b0082;
                        margin-bottom: 1rem;
                    }}
                    a {{
                        display: inline-block;
                        margin-top: 1rem;
                        padding: 0.75rem 1.5rem;
                        background-color: #8a2be2;
                        color: #fff;
                        text-decoration: none;
                        border-radius: 6px;
                        font-weight: bold;
                        transition: background-color 0.3s;
                    }}
                    a:hover {{
                        background-color: #7a1ecf;
                    }}
                </style>
            </head>
            <body>
                <div class='card'>
                    <h1>{message}</h1>
                    <a href='{loginUrl}'>Go to Login</a>
                </div>
            </body>
            </html>";
        }
    }
}


===== Middlewares/ExceptionHandlingMiddleware.cs =====
using System.Net;
using System.Text.Json;
using YuGiOh.Domain.Exceptions;

namespace YuGiOh.WebAPI.Middlewares
{
    /// <summary>
    /// Middleware responsible for centralized exception handling across the Web API.
    /// </summary>
    /// <remarks>
    /// This middleware ensures that all unhandled exceptions are caught and translated into
    /// standardized JSON responses. It supports both <see cref="APIException"/> for expected
    /// domain or application-level errors, and generic <see cref="Exception"/> for unexpected ones.
    /// </remarks>
    public class ExceptionHandlingMiddleware
    {
        private readonly RequestDelegate _next;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExceptionHandlingMiddleware"/> class.
        /// </summary>
        /// <param name="next">The next middleware in the HTTP request pipeline.</param>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="next"/> is null.</exception>
        public ExceptionHandlingMiddleware(RequestDelegate next)
        {
            _next = next ?? throw new ArgumentNullException(nameof(next));
        }

        /// <summary>
        /// Invokes the middleware for the current HTTP request context.
        /// </summary>
        /// <param name="context">The current <see cref="HttpContext"/>.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        /// <remarks>
        /// This method wraps the downstream request execution in a try/catch block and handles:
        /// <list type="bullet">
        /// <item>
        /// <description><see cref="APIException"/> — Translated into structured error responses with proper status codes.</description>
        /// </item>
        /// <item>
        /// <description>Unhandled <see cref="Exception"/> — Returns a 500 Internal Server Error with a generic message.</description>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                // Continue to the next middleware or request handler
                await _next(context);
            }
            catch (APIException ex)
            {
                // Handle known API exceptions in a standardized format
                context.Response.ContentType = "application/json";
                context.Response.StatusCode = (int)ex.StatusCode;

                var responseBody = JsonSerializer.Serialize(ex.ToSerializableObject());
                await context.Response.WriteAsync(responseBody);
            }
            catch (Exception ex)
            {
                // Handle unexpected, non-API exceptions (internal errors)
                context.Response.ContentType = "application/json";
                context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;

                var responseBody = JsonSerializer.Serialize(new
                {
                    status = 500,
                    title = "Internal Server Error",
                    message = ex.Message,
                    timestamp = DateTime.UtcNow
                });

                await context.Response.WriteAsync(responseBody);
            }
        }
    }
}

/*
    To enable this middleware, register it in the request pipeline:

    app.UseMiddleware<ExceptionHandlingMiddleware>();

    This should be placed early in the pipeline (right after `UseRouting()` 
    and before other middleware that may throw exceptions).
*/


===== obj/Debug/net7.0/.NETCoreApp,Version=v7.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v7.0", FrameworkDisplayName = ".NET 7.0")]


===== obj/Debug/net7.0/YuGiOh.WebAPI.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("YuGiOh.WebAPI")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("YuGiOh.WebAPI")]
[assembly: System.Reflection.AssemblyTitleAttribute("YuGiOh.WebAPI")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



===== obj/Debug/net7.0/YuGiOh.WebAPI.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;


===== obj/Debug/net7.0/YuGiOh.WebAPI.MvcApplicationPartsAssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.Identity.UI")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.OpenApi")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("YuGiOh.Infrastructure")]

// Generated by the MSBuild WriteCodeFragment class.



===== Program.cs =====

using YuGiOh.WebAPI.Middlewares;
using YuGiOh.Infrastructure;
using YuGiOh.Application;

var builder = WebApplication.CreateBuilder(args);

// =====================================================
// 1. Add Services
// =====================================================

// Add Controllers + System.Text.Json options
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.PropertyNamingPolicy = null;
    });

// Swagger
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// CORS (for React)
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowReactApp", policy =>
        policy.WithOrigins("http://localhost:3000") // React dev server
              .AllowAnyHeader()
              .AllowAnyMethod());
});

builder.Services.AddLogging();

// Infrastructure (Persistence + Identity + Email + CSC + Seeding + Caching)
builder.Services.AddInfrastructureLayer(builder.Configuration);
builder.Services.AddApplicationLayer();

var app = builder.Build();

// =====================================================
// 2. Configure Middleware
// =====================================================

app.UseMiddleware<ExceptionHandlingMiddleware>();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Use HTTPS redirection (recommended)
app.UseHttpsRedirection();

// Use CORS for the React frontend
app.UseCors("AllowReactApp");

// Authentication / Authorization
app.UseAuthentication(); // <— Needed if you use Identity
app.UseAuthorization();

// Map Controllers
app.MapControllers();

// =====================================================
// 3. (Optional) Seed Database
// =====================================================


app.Run();


===== YuGiOh.WebAPI.csproj =====
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="7.0.19" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="7.0.20">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\YuGiOh.Application\YuGiOh.Application.csproj" />
    <ProjectReference Include="..\YuGiOh.Infrastructure\YuGiOh.Infrastructure.csproj" />
  </ItemGroup>

</Project>


